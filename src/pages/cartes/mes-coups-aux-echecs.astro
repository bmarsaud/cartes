---
import Tabs from "../../components/Tabs.astro";
const map = {
    "title": "Mes coups aux échecs",
    "abstract": "Pour le thème « Out of this world » du #30DayMapChallenge je vous propose de plonger dans le monde fascinant des échecs avec une cartographie des coups joués dans mes parties.",
    "description": "À l'occasion du thème « Out of this world » du <a href='https://30daymapchallenge.com/' target='_blank' class='underline cursor-pointer '>#30DayMapChallenge</a>, je vous propose d'explorer le monde fascinant des échecs avec cette visualisation du nombre de coups que j'ai joué par case de l'échiquier, couleur et pièce durant mes quelque 2300 parties sur <span class='italic'>Chess.com</span>. On voit bien que je suis un joueur de <span class='italic'>d4</span>.",
    "date": "2025-11-18"
};

import MapLayout from "../../layouts/MapLayout.astro";
---
<MapLayout {...map}>
    <div id="map" class="h-[60vh] lg:h-full w-full relative">
        <div class="absolute top-0 right-0 p-2 z-20 flex flex-col items-end gap-2 font-serif text-xs sm:text-base">
            <div class="z-20 bg-[#fffaea] border p-2 pt-1 flex flex-wrap gap-2 md:gap-4" x-data="{}">
                <div @tab-selected="window.updateState('color', $event.detail.value)">
                    <h3 class="font-semibold">Couleur</h3>
                    <Tabs elements={["N&B", "Noirs", "Blancs"]} initialValue="N&B"></Tabs>
                </div>
                <div @tab-selected="window.updateState('pieces', $event.detail.value)">
                    <h3 class="font-semibold">Pièces</h3>
                    <Tabs elements={["Toutes", "♟", "♞", "♝", "♜", "♛", "♚"]} initialValue="Toutes"></Tabs>
                </div>
            </div>
        </div>
        <div id="tooltip" class="absolute left-0 top-0 z-20 bg-[#fffaea] border p-2 md:pointer-events-none min-w-24" style="display: none;">
            <div class="border-b mb-1 flex justify-between items-center" x-data="{}">
                <h3 class="font-[600]" id="square"></h3>
            </div>
            <div class="text-sm" id="pieces-count"></div>
        </div>
    </div>
</MapLayout>

<script>
    import 'ol/ol.css';
    import {default as OlMap} from 'ol/Map';
    import View from 'ol/View';
    import VectorLayer from 'ol/layer/Vector';
    import VectorSource from 'ol/source/Vector';
    import GeoJSON from 'ol/format/GeoJSON';
    import {Fill, Stroke, Style, Text} from "ol/style";
    import {interpolateReds} from "d3-scale-chromatic";
    import type {FeatureLike} from "ol/Feature";

    const COLORS_FILTER: Record<string, string[]> = {
        'N&B': [ 'b', 'w' ],
        'Blancs': [ 'w' ],
        'Noirs': [ 'b' ]
    }

    const PIECES_FILTER: Record<string, string[]> = {
        'Toutes': [ 'p', 'n', 'b', 'r', 'q', 'k' ],
        "♟": ["p"],
        "♞": ["n"],
        "♝": ["b"],
        "♜": ["r"],
        "♛": ["q"],
        "♚": ["k"]
    }

    const PIECES_ICON: Record<string, string> = {
        "p": "♟",
        "n": "♞",
        "b": "♝",
        "r": "♜",
        "q": "♛",
        "k": "♚"
    }

    loadMap();
    async function loadMap() {
        // data
        const heatmap = await fetch('/data/mes-coups-aux-echecs/chess-heatmap.json').then(res => res.json());
        const boardSource = new VectorSource({
            url: '/data/mes-coups-aux-echecs/board.geo.json',
            format: new GeoJSON(),
        });

        // state
        const state = {
            color: 'N&B',
            pieces: 'Toutes',
            maxValue: 0,
            hoveredFeature: null as FeatureLike | null
        };
        state.maxValue = getMaxValue();

        function getHeatmapValue(square: string, colors: string[], pieces: string[]): number {
            let value = 0;
            for (let color of colors) {
                for (let piece of pieces) {
                    value += heatmap[square][color][piece] ?? 0;
                }
            }
            return value;
        }

        function getCurrentHeatmapValue(square: string) {
            return getHeatmapValue(square, COLORS_FILTER[state.color], PIECES_FILTER[state.pieces]);
        }

        function getMaxValue() {
            let max = 0;
            for (let square of Object.keys(heatmap)) {
                max = Math.max(max, getCurrentHeatmapValue(square));
            }
            return max;
        }

        const boardLayer = new VectorLayer({
            source: boardSource,
            style: (feature, resolution) => {
                let square = feature.get('col') + feature.get('row');

                let text;
                if (feature.get('col') === 'a') {
                    text = new Text({
                        text: feature.get('row'),
                        font: '500 18px "Source Serif 4"',
                        fill: new Fill({
                            color: '#000000'
                        }),
                        offsetX: - 1 / resolution,
                    })
                }

                return new Style({
                    stroke: new Stroke(),
                    fill: new Fill({
                        color: interpolateReds(getCurrentHeatmapValue(square) / state.maxValue),
                    }),
                    text
                });
            }
        });

        // We use a dedicated layer for column labels to avoid automatic label decluttering that could hide the 1 row label
        const columnsLayer = new VectorLayer({
            source: boardSource,
            style: (feature, resolution) => {
                let text;
                if (feature.get('row') === 1) {
                    text = new Text({
                        text: feature.get('col'),
                        font: '500 18px "Source Serif 4"',
                        fill: new Fill({
                            color: '#000000'
                        }),
                        offsetY: 1 / resolution,
                    })
                }

                return new Style({text})
            },
        })

        const map = new OlMap({
            target: 'map',
            layers: [
                boardLayer,
                columnsLayer
            ],
            view: new View({
                projection: 'EPSG:4326',
                center: [4, 4],
                zoom: 7,
            }),
        });

        boardSource.on('featuresloadend', function() {
            map.getView().fit(boardSource.getExtent(), { padding: [80, 80, 80, 80] });
        });

        (window as any).updateState = (key: 'color' | 'pieces', value: string) => {
            state[key] = value;
            state.maxValue = getMaxValue();
            boardSource.changed();
        }

        // map hover
        let tooltipElem = document.getElementById('tooltip')!;
        let squareElem = document.getElementById('square')!;
        let piecesCountElem = document.getElementById('pieces-count')!;

        map.on('pointermove', function (evt) {
            if (evt.dragging) {
                return;
            }
            updateTooltip(evt);
        });

        map.on('click', function (evt) {
            if (state.hoveredFeature) {
                state.hoveredFeature = null;
                tooltipElem.style.display = 'none';
            }
            updateTooltip(evt);
        });

        function updateTooltip(evt: any) {
            boardLayer.getFeatures(evt.pixel).then((features) => {
                let feature = features.pop();
                if (state.hoveredFeature) {
                    state.hoveredFeature = null;
                }

                if (feature) {
                    state.hoveredFeature = feature;

                    tooltipElem.style.left = evt.pixel[0] + 12 + 'px';
                    tooltipElem.style.top = evt.pixel[1] + 12 + 'px';
                    tooltipElem.style.display = 'block';

                    squareElem.innerText = feature.get('col') + feature.get('row');

                    let piecesCountHtml = '';
                    for (let piece of PIECES_FILTER[state.pieces]) {
                        piecesCountHtml += `<div class="">${PIECES_ICON[piece]} ${getHeatmapValue(feature.get('col') + feature.get('row'), COLORS_FILTER[state.color], [piece])}</div>`
                    }
                    piecesCountElem.innerHTML = piecesCountHtml;
                }
            });

            if (!state.hoveredFeature) {
                tooltipElem.style.display = 'none';
            }
        }
    }
</script>
